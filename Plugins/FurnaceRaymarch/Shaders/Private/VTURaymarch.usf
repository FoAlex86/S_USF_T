//==========================================================================================================	//==========================================================================================================	//==========================================================================================================	//==========================================================================================================	//==========================================================================================================

// RaymarchVTU.usf
// =============================================================
// GPU first-hit raycast through VTU cells using an octree.
// Ecrit une texture RGBA (RGB = coloration par feature, A = profondeur normalisée).
// Ignore le clipping et les clones
// =============================================================

#include "/Engine/Private/Common.ush"
#define RM_DEBUG 1 // niveaux de sorties debug (1..4) ;
// -----------------------------------------------------------------------------
// UAV de sortie : texture 2D
RWTexture2D<float4> OutTex;

// Résolution de la cible
uint2 RTSize;
uint RTWidth;
uint RTHeight;

// Matrices
//  - InvViewProj : permet de reconstruire des positions monde depuis (uv,z)
//  - WorldToLocal : convertit des points/vecteurs monde -> espace local du volume
float4x4 InvViewProj;
float4x4 WorldToLocal;

// Boîte englobante ACTIVE en LOCAL SPACE (union des clones ou 1/8)
float4 UnionMinLS4; // xyz = MinLS
float4 UnionMaxLS4; // xyz = MaxLS

// ===== Données VTU (grille) poussées par le CPU sous forme de StructuredBuffer ====
StructuredBuffer<float3> Points; // positions en Local Space (cm)
StructuredBuffer<uint> Conn; // connectivité concaténée
StructuredBuffer<uint> Offs; // offsets (prefix sums) par cellule -> end index dans Conn
StructuredBuffer<uint> Types; // VTK cell type par cellule
StructuredBuffer<float> FeatureVals; // valeur scalaire par cellule (feature sélectionnée)
StructuredBuffer<int> Faces; // polyhedron face stream
StructuredBuffer<int> FaceOffsets; // offsets (prefix sums) dans Faces
uint NumPoints;
uint NumCells;

// --- Octree (cell proxies) ---
StructuredBuffer<float3> OctNodeCenter;
StructuredBuffer<float3> OctNodeExtent;
StructuredBuffer<int> OctNodeFirstChild; // index dans NodeChildIndex
StructuredBuffer<uint> OctNodeChildCount; // 0 => leaf
StructuredBuffer<int> OctNodeFirstElem; // index dans la liste d'éléments
StructuredBuffer<uint> OctNodeElemCount;
StructuredBuffer<int> NodeChildIndex; // tableau linéaire d'indices de noeuds enfants
StructuredBuffer<float3> ElemMin; // AABB local par élément
StructuredBuffer<float3> ElemMax;
StructuredBuffer<int> ElemCell; // map élément -> index cellule
uint NumNodes;
uint NumElems;
uint RootIndex;

// --- Params additionnels (GPU == CPU) ---
float VMin;
float VMax;
float EpsCm; // ~ Max(0.05*Step, 0.25) côté CPU
float3 CameraPosWS; // position caméra monde (pour alpha ou debug)

// -----------------------------------------------------------------------------
// Utils

// Unproject NDC (z dans [0..1]) vers World Space via InvViewProj.
// Permet de reconstruire deux points monde (near/far) sur le rayon de pixel.
float3 UnprojectToWorld(float2 uv, float zClip)
{
    // UV viewport (0..1) -> NDC (-1..+1)
    float2 ndc = float2(uv.x * 2.0 - 1.0, 1.0 - uv.y * 2.0); // Y flip
    
    //coordonnées homogènes après projection (x,y,z,w)
    float4 clipPosH = float4(ndc.xy, zClip, 1.0);
    
    // matrice inverse ViewProj pour revenir en WS
    float4 worldPosH = mul(InvViewProj, clipPosH);
    //float4 wH = mul(clipPosH, InvViewProj);
    
    // division homogène retour WS coordonnées cartésiennes
    return worldPosH.xyz / max(worldPosH.w, 1e-8);
}

// Transforme un vecteur (pas un point) WS -> LS
float3 TransformDir_WorldToLocal(float3 vWS)
{
    float4 vL = mul(WorldToLocal, float4(vWS, 0.0));
    return vL.xyz;
}

// Transforme un point WS -> LS
float3 TransformPoint_WorldToLocal(float3 pWS)
{
    float4 pL = mul(WorldToLocal, float4(pWS, 1.0));
    return pL.xyz;
}

// Ray <-> AABB (Axis-Aligned Bounding Box), en Local Space
bool IntersectRayAABB_Slab(float3 rayOriginLS, float3 rayDirectionLS, float3 boxMinLS, float3 boxMaxLS, out float tEnter, out float tExit)
{
    //float3 inv = 1.0 / max(abs(rd), 1e-20).xxx * sign(rd); // éviter division par 0
    float3 t1 = (boxMinLS - rayOriginLS) * (1.0 / rayDirectionLS);
    float3 t2 = (boxMaxLS - rayOriginLS) * (1.0 / rayDirectionLS);

    float3 tNearAxis = min(t1, t2);
    float3 tFarAxis = max(t1, t2);

    tEnter = max(max(tNearAxis.x, tNearAxis.y), tNearAxis.z);
    tExit = min(min(tFarAxis.x, tFarAxis.y), tFarAxis.z);

    return tExit >= max(tEnter, 0.0);
}

// Normale orientée vers l'intérieur (selon centroïde C)
float3 FaceInwardNormal(float3 p0, float3 p1, float3 p2, float3 C)
{
    float3 n = normalize(cross(p1 - p0, p2 - p0));
    if (dot(n, C - p0) > 0.0)
        n *= -1.0;
    return n;
}

// Gradient de couleur (identique à ScalarToColor côté CPU)
float3 ScalarToColorRGB(float v, float vmin, float vmax)
{
    if (!(vmax > vmin))
        return float3(0.5, 0.5, 0.5);
    float t = saturate((v - vmin) / (vmax - vmin));

    // Stops en sRGB (0..1) équivalents aux FColor(…) CPU
    const float3 Stops[6] =
    {
        float3(34.0 / 255.0, 31.0 / 255.0, 123.0 / 255.0), // bleu
        float3(36.0 / 255.0, 132.0 / 255.0, 181.0 / 255.0), // cyan
        float3(67.0 / 255.0, 174.0 / 255.0, 132.0 / 255.0), // vert-bleuté
        float3(160.0 / 255.0, 190.0 / 255.0, 80.0 / 255.0), // jaune-vert
        float3(220.0 / 255.0, 152.0 / 255.0, 66.0 / 255.0), // orange
        float3(220.0 / 255.0, 49.0 / 255.0, 32.0 / 255.0) // rouge
    };

    float f = t * 5.0;
    int i = clamp(int(floor(f)), 0, 4);
    float u = f - float(i);
    return lerp(Stops[i], Stops[i + 1], u);
}

// -----------------------------------------------------------------------------
// Lecture faces VTK par type

// Retourne start/end dans Conn pour la cellule ci.
void CellConnRange(int ci, out uint start, out uint end)
{
    start = (ci == 0) ? 0u : Offs[ci - 1];
    end = Offs[ci];
}

// Calcule le centroïde de la cellule (en LS) en moyennant ses sommets
float3 CellCentroidLS(int ci)
{
    uint s, e;
    CellConnRange(ci, s, e);
    float3 C = 0.0;
    uint n = 0u;

    [loop]
    for (uint k = s; k < e; ++k)
    {
        uint vi = Conn[k];
        if (vi < NumPoints)
        {
            C += Points[vi];
            n += 1u;
        }
    }
    return (n > 0u) ? (C / float(max(n, 1u))) : 0.0.xxx;
}

// Applique un “demi-espace” pour mettre à jour tEnter/tExit
void ApplyPlaneInterval(float3 p0, float3 p1, float3 p2, float3 C, float3 ro, float3 rd, float eps, inout float tEnter, inout float tExit, inout bool hadFace)
{
    float3 n = FaceInwardNormal(p0, p1, p2, C);
    float Nd = dot(n, rd);
    float No = dot(n, ro - p0);

    hadFace = true;

    if (abs(Nd) < 1e-8)
    {
        // Rayon // au plan : si clairement dehors, on invalide l’intervalle
        if (No > eps)
        {
            tEnter = 1.0;
            tExit = 0.0;
        } // dehors
        return;
    }

    float tHit = -No / Nd;
    if (Nd < 0.0)
        tEnter = max(tEnter, tHit);
    else
        tExit = min(tExit, tHit);
}

// Vérifie que le point d'entrée pEnt est bien "inside" (toutes les faces côté intérieur)  (t == tEnter clampé >= 0)
bool InsideAtEntry(float3 pEnt, int ci, uint ty, float3 C)
{
    uint s, e;
    CellConnRange(ci, s, e);

    // ----- TETRA (VTK_TETRA = 10)
    if (ty == 10u) 
    {
        uint v0 = Conn[s + 0], v1 = Conn[s + 1], v2 = Conn[s + 2], v3 = Conn[s + 3];
        float3 P[4] = { Points[v0], Points[v1], Points[v2], Points[v3] };
        // 4 faces
        float3 n;
        float d;
        float3 Q0, Q1, Q2;

        // (0,1,2)
        Q0 = P[0];
        Q1 = P[1];
        Q2 = P[2];
        n = FaceInwardNormal(Q0, Q1, Q2, C);
        if (dot(n, pEnt - Q0) > EpsCm)
            return false;
        // (0,3,1)
        Q0 = P[0];
        Q1 = P[3];
        Q2 = P[1];
        n = FaceInwardNormal(Q0, Q1, Q2, C);
        if (dot(n, pEnt - Q0) > EpsCm)
            return false;
        // (1,3,2)
        Q0 = P[1];
        Q1 = P[3];
        Q2 = P[2];
        n = FaceInwardNormal(Q0, Q1, Q2, C);
        if (dot(n, pEnt - Q0) > EpsCm)
            return false;
        // (0,2,3)
        Q0 = P[0];
        Q1 = P[2];
        Q2 = P[3];
        n = FaceInwardNormal(Q0, Q1, Q2, C);
        if (dot(n, pEnt - Q0) > EpsCm)
            return false;

        return true;
    }
    // ----- HEXAHEDRON (VTK_HEXAHEDRON = 12)
    else if (ty == 12u) 
    {
        uint v[8];
        [unroll]
        for (uint i = 0; i < 8; i++)
            v[i] = Conn[s + i];
        float3 P[8];
        [unroll]
        for (uint i = 0; i < 8; i++)
            P[i] = Points[v[i]];

        uint4 F[6] =
        {
            uint4(0, 1, 2, 3),
            uint4(4, 5, 6, 7),
            uint4(0, 4, 5, 1),
            uint4(1, 5, 6, 2),
            uint4(2, 6, 7, 3),
            uint4(3, 7, 4, 0)
        };

        [unroll]
        for (int f = 0; f < 6; ++f)
        {
            float3 p0 = P[F[f].x], p1 = P[F[f].y], p2 = P[F[f].z];
            float3 n = FaceInwardNormal(p0, p1, p2, C);
            if (dot(n, pEnt - p0) > EpsCm)
                return false;
        }
        return true;
    }
    // ----- WEDGE (VTK_WEDGE = 13)
    else if (ty == 13u) 
    {
        uint v[6];
        [unroll]
        for (uint i = 0; i < 6; i++)
            v[i] = Conn[s + i];
        float3 P[6];
        [unroll]
        for (uint i = 0; i < 6; i++)
            P[i] = Points[v[i]];

        // faces: (0,1,2), (3,4,5), quads (0,3,4,1), (1,4,5,2), (2,5,3,0)
        uint3 T[2] = { uint3(0, 1, 2), uint3(3, 4, 5) };
        [unroll]
        for (int f = 0; f < 2; ++f)
        {
            float3 p0 = P[T[f].x], p1 = P[T[f].y], p2 = P[T[f].z];
            float3 n = FaceInwardNormal(p0, p1, p2, C);
            if (dot(n, pEnt - p0) > EpsCm)
                return false;
        }

        uint4 Q[3] = { uint4(0, 3, 4, 1), uint4(1, 4, 5, 2), uint4(2, 5, 3, 0) };
        [unroll]
        for (int f = 0; f < 3; ++f)
        {
            float3 p0 = P[Q[f].x], p1 = P[Q[f].y], p2 = P[Q[f].z];
            float3 n = FaceInwardNormal(p0, p1, p2, C);
            if (dot(n, pEnt - p0) > EpsCm)
                return false;
        }
        return true;
    }
    // ----- PYRAMID (VTK_PYRAMID = 14)
    else if (ty == 14u) 
    {
        uint v[5];
        [unroll]
        for (uint i = 0; i < 5; i++)
            v[i] = Conn[s + i];
        float3 P[5];
        [unroll]
        for (uint i = 0; i < 5; i++)
            P[i] = Points[v[i]];

        // base quad + 4 triangles
        uint4 baseQ = uint4(0, 1, 2, 3);
        float3 p0 = P[baseQ.x], p1 = P[baseQ.y], p2 = P[baseQ.z];
        float3 n = FaceInwardNormal(p0, p1, p2, C);
        if (dot(n, pEnt - p0) > EpsCm)
            return false;

        uint3 T[4] = { uint3(0, 4, 1), uint3(1, 4, 2), uint3(2, 4, 3), uint3(3, 4, 0) };
        [unroll]
        for (int f = 0; f < 4; ++f)
        {
            float3 q0 = P[T[f].x], q1 = P[T[f].y], q2 = P[T[f].z];
            float3 n2 = FaceInwardNormal(q0, q1, q2, C);
            if (dot(n2, pEnt - q0) > EpsCm)
                return false;
        }
        return true;
    }
    // ----- POLYHEDRON (VTK_POLYHEDRON = 42) : faces lues dans Faces/FaceOffsets
    else if (ty == 42u) 
    {
        int sF = (ci == 0) ? 0 : FaceOffsets[ci - 1];
        int eF = FaceOffsets[ci];
        int idx = sF;

        if (idx >= eF)
            return false;
        int nFaces = Faces[idx++];

        [loop]
        for (int f = 0; f < nFaces && idx < eF; ++f)
        {
            if (idx >= eF)
                break;
            int nv = Faces[idx++]; // nombre de sommets de la face
            if (nv < 3 || idx + nv > eF)
            {
                idx = eF;
                break;
            }

            int v0 = Faces[idx + 0];
            int v1 = Faces[idx + 1];
            int v2 = Faces[idx + 2];
            float3 p0 = Points[v0];
            float3 p1 = Points[v1];
            float3 p2 = Points[v2];

            float3 n = FaceInwardNormal(p0, p1, p2, C);
            if (dot(n, pEnt - p0) > EpsCm)
                return false;

            idx += nv;
        }
        return true;
    }

    // Type non pris en charge
    return false;
}

// Calcule tEnter/tExit en agrégeant les faces de la cellule  (plane clipping)
bool CellEntryInterval(int ci, float3 ro, float3 rd, float eps, out float tEnter, out float tExit)
{
    tEnter = 0.0;
    tExit = 1e30;
    bool hadFace = false;

    uint s, e;
    CellConnRange(ci, s, e);
    uint ty = Types[ci];
    float3 C = CellCentroidLS(ci);

    // Cas supportés : TETRA, HEXA, WEDGE, PYRAMID, POLYHEDRON
    if (ty == 10u) // TETRA
    {
        uint v0 = Conn[s + 0], v1 = Conn[s + 1], v2 = Conn[s + 2], v3 = Conn[s + 3];
        float3 P0 = Points[v0], P1 = Points[v1], P2 = Points[v2], P3 = Points[v3];

        ApplyPlaneInterval(P0, P1, P2, C, ro, rd, eps, tEnter, tExit, hadFace);
        ApplyPlaneInterval(P0, P3, P1, C, ro, rd, eps, tEnter, tExit, hadFace);
        ApplyPlaneInterval(P1, P3, P2, C, ro, rd, eps, tEnter, tExit, hadFace);
        ApplyPlaneInterval(P0, P2, P3, C, ro, rd, eps, tEnter, tExit, hadFace);
    }
    else if (ty == 12u) // HEXA
    {
        uint v[8];
        [unroll]
        for (uint i = 0; i < 8; i++)
            v[i] = Conn[s + i];
        float3 P[8];
        [unroll]
        for (uint i = 0; i < 8; i++)
            P[i] = Points[v[i]];

        uint4 Q[6] =
        {
            uint4(0, 1, 2, 3),
            uint4(4, 5, 6, 7),
            uint4(0, 4, 5, 1),
            uint4(1, 5, 6, 2),
            uint4(2, 6, 7, 3),
            uint4(3, 7, 4, 0)
        };

        [unroll]
        for (int f = 0; f < 6; ++f)
        {
            float3 p0 = P[Q[f].x], p1 = P[Q[f].y], p2 = P[Q[f].z];
            ApplyPlaneInterval(p0, p1, p2, C, ro, rd, eps, tEnter, tExit, hadFace);
        }
    }
    else if (ty == 13u) // WEDGE
    {
        uint v[6];
        [unroll]
        for (uint i = 0; i < 6; i++)
            v[i] = Conn[s + i];
        float3 P[6];
        [unroll]
        for (uint i = 0; i < 6; i++)
            P[i] = Points[v[i]];

        uint3 T[2] = { uint3(0, 1, 2), uint3(3, 4, 5) };
        [unroll]
        for (int f = 0; f < 2; ++f)
        {
            float3 p0 = P[T[f].x], p1 = P[T[f].y], p2 = P[T[f].z];
            ApplyPlaneInterval(p0, p1, p2, C, ro, rd, eps, tEnter, tExit, hadFace);
        }

        uint4 Q[3] = { uint4(0, 3, 4, 1), uint4(1, 4, 5, 2), uint4(2, 5, 3, 0) };
        [unroll]
        for (int f = 0; f < 3; ++f)
        {
            float3 p0 = P[Q[f].x], p1 = P[Q[f].y], p2 = P[Q[f].z];
            ApplyPlaneInterval(p0, p1, p2, C, ro, rd, eps, tEnter, tExit, hadFace);
        }
    }
    else if (ty == 14u) // PYRAMID
    {
        uint v[5];
        [unroll]
        for (uint i = 0; i < 5; i++)
            v[i] = Conn[s + i];
        float3 P[5];
        [unroll]
        for (uint i = 0; i < 5; i++)
            P[i] = Points[v[i]];

        uint4 B = uint4(0, 1, 2, 3);
        ApplyPlaneInterval(P[B.x], P[B.y], P[B.z], CellCentroidLS(ci), ro, rd, eps, tEnter, tExit, hadFace);

        uint3 T[4] = { uint3(0, 4, 1), uint3(1, 4, 2), uint3(2, 4, 3), uint3(3, 4, 0) };
        [unroll]
        for (int f = 0; f < 4; ++f)
        {
            ApplyPlaneInterval(P[T[f].x], P[T[f].y], P[T[f].z], CellCentroidLS(ci), ro, rd, eps, tEnter, tExit, hadFace);
        }
    }
    else if (ty == 42u) // POLYHEDRON
    {
        int sF = (ci == 0) ? 0 : FaceOffsets[ci - 1];
        int eF = FaceOffsets[ci];
        int idx = sF;

        if (idx < eF)
        {
            int nFaces = Faces[idx++];

            [loop]
            for (int f = 0; f < nFaces && idx < eF; ++f)
            {
                if (idx >= eF)
                    break;
                int nv = Faces[idx++]; // sommets de la face
                if (nv < 3 || idx + nv > eF)
                {
                    idx = eF;
                    break;
                }

                int v0 = Faces[idx + 0];
                int v1 = Faces[idx + 1];
                int v2 = Faces[idx + 2];

                float3 p0 = Points[v0];
                float3 p1 = Points[v1];
                float3 p2 = Points[v2];

                ApplyPlaneInterval(p0, p1, p2, CellCentroidLS(ci), ro, rd, eps, tEnter, tExit, hadFace);

                idx += nv;
            }
        }
    }
    else
    {
        // Type non géré -> pas d'intersection
        return false;
    }

    if (!hadFace)
        return false;
    if (tEnter > tExit)
        return false;
    if (tExit < 0.0)
        return false;
    return true;
}

// Test ray -> cellule convexe, renvoie le premier t >= 0 si inside
bool RayIntersectConvexCell_FirstT(int ci, float3 ro, float3 rd, float eps, out float tEntry)
{
    float tEnter, tExit;
    if (!CellEntryInterval(ci, ro, rd, eps, tEnter, tExit))
        return false;

    float tEnt = max(0.0, tEnter);
    float3 pEnt = ro + rd * tEnt;

    uint ty = Types[ci];
    float3 C = CellCentroidLS(ci);
    if (!InsideAtEntry(pEnt, ci, ty, C))
        return false;

    tEntry = tEnt;
    return true;
}

// -----------------------------------------------------------------------------
// Octree traversal (stack) — closest-first via tNear triage

#define MAX_STACK 64

// Raycast "first hit" en Local Space contre l’octree + cellules
bool RaycastFirstCellLS(float3 rayOriginLS, float3 rayDirectionLS, out int outCi, out float outT)
{
    outCi = -1;
    outT = 1e30;

    // Clip global sur l’AABB active (union LS)
    float3 boxMinLS = UnionMinLS4.xyz;
    float3 boxMaxLS = UnionMaxLS4.xyz;

    float tU0, tU1;
    if (!IntersectRayAABB_Slab(rayOriginLS, rayDirectionLS, boxMinLS, boxMaxLS, tU0, tU1))
        return false;

    // Petit padding (même logique CPU) pour éviter les faux négatifs sur bords
    float3 pad = max(0.5 * EpsCm, 0.25).xxx;

    // Pile de nodes à visiter (indices + tNear)
    int stackNode[MAX_STACK];
    float stackTN[MAX_STACK];
    int sp = 0;

    // Push root si intersecté
    {
        float3 bmin = OctNodeCenter[RootIndex] - OctNodeExtent[RootIndex];
        float3 bmax = OctNodeCenter[RootIndex] + OctNodeExtent[RootIndex];
        float t0, t1;
        if (IntersectRayAABB_Slab(rayOriginLS, rayDirectionLS, bmin, bmax, t0, t1))
        {
            stackNode[sp] = RootIndex;
            stackTN[sp] = t0;
            sp++;
        }
        else
        {
            return false;
        }
    }
    // Parcours DFS avec sélection du tNear minimum à chaque pop (approx. priority queue)
    [loop]
    while (sp > 0)
    {
        // pop le plus proche (tNear minimal)
        int bestI = 0;
        float bestTN = stackTN[0];
        [loop]
        for (int i = 1; i < sp; ++i)
        {
            if (stackTN[i] < bestTN)
            {
                bestTN = stackTN[i];
                bestI = i;
            }
        }
        int node = stackNode[bestI];
        // compacter
        sp--;
        stackNode[bestI] = stackNode[sp];
        stackTN[bestI] = stackTN[sp];

        // passe si déjà plus loin que notre meilleur hit
        if (bestTN > outT)
            continue;

        uint childCount = OctNodeChildCount[node];
        if (childCount == 0u)
        {
            // feuille -> tester éléments
            int e0 = OctNodeFirstElem[node];
            uint ec = OctNodeElemCount[node];

            [loop]
            for (uint k = 0; k < ec; ++k)
            {
                int e = e0 + int(k);
                float3 ebmin = ElemMin[e] - pad;
                float3 ebmax = ElemMax[e] + pad;

                float t0, t1;
                if (!IntersectRayAABB_Slab(rayOriginLS, rayDirectionLS, ebmin, ebmax, t0, t1))
                    continue;
                if (t1 < 0.0 || t0 > outT)
                    continue;

                int ci = ElemCell[e];
                if (ci < 0 || ci >= int(NumCells))
                    continue;

                float tEnt;
                if (RayIntersectConvexCell_FirstT(ci, rayOriginLS, rayDirectionLS, EpsCm, tEnt))
                {
                    if (tEnt >= 0.0 && tEnt < outT)
                    {
                        outT = tEnt;
                        outCi = ci;
                    }
                }
            }
        }
        else
        {
            // Node interne : empile les enfants intersectés (si tNear <= meilleur hit courant)
            int fc = OctNodeFirstChild[node];

            [loop]
            for (uint i = 0; i < childCount; ++i)
            {
                int c = NodeChildIndex[fc + int(i)];
                float3 bmin = OctNodeCenter[c] - OctNodeExtent[c];
                float3 bmax = OctNodeCenter[c] + OctNodeExtent[c];
                float t0, t1;
                if (IntersectRayAABB_Slab(rayOriginLS, rayDirectionLS, bmin, bmax, t0, t1))
                {
                    if (t0 <= outT)
                    {
                        if (sp < MAX_STACK)
                        {
                            stackNode[sp] = c;
                            stackTN[sp] = t0;
                            sp++;
                        }
                    }
                }
            }
        }
    }

    return (outCi >= 0);
}

// -----------------------------------------------------------------------------
// Compute kernel

[numthreads(8, 8, 1)]
void MainCS(uint3 DTid : SV_DispatchThreadID)
{
    //zone de rendu
    if (DTid.x >= RTWidth || DTid.y >= RTHeight)
        return;
    
    // Normalisation pixel -> uv [0..1] (centre de pixel)
    float2 uv = (float2(DTid.xy) + 0.5) / float2(RTSize);
    //float2 ndc = float2(uv.x * 2.0 - 1.0, 1.0 - uv.y * 2.0);

    //--------------------------------------------------------------
    //// Deux unprojections : z=0 et z=1
    //    float4 w0 = mul(InvViewProj, float4(ndc, 0.0, 1.0));
    //    float4 w1 = mul(InvViewProj, float4(ndc, 1.0, 1.0));
    //    float3 p0 = w0.xyz / max(w0.w, 1e-8);
    //    float3 p1 = w1.xyz / max(w1.w, 1e-8);

    //// Origine = caméra
    //    float3 rayOrigin = CameraPosWS;
    //    float d0 = distance(p0, rayOrigin);
    //    float d1 = distance(p1, rayOrigin);
    //    float3 rayDirection = normalize((d1 > d0 ? p1 : p0) - rayOrigin);

    //// Passage en LOCAL + normalisation
    //    float3 rayOriginLS = TransformPoint_WorldToLocal(rayOrigin);
    //    float3 rayDirectionLS = TransformDir_WorldToLocal(rayDirection);
    //    rayDirectionLS /= max(length(rayDirectionLS), 1e-8);
    //--------------------------------------------------------------

    //// Reconstruction du rayon monde à partir de la caméra :
    //float3 pNearWS = UnprojectToWorld(uv, 0.0);
    //float3 pFarWS = UnprojectToWorld(uv, 1.0);
    //float3 rayOrigin = CameraPosWS; // origine = caméra 
    ////float3 rayOrigin = pNearWS;
    //float3 rayDirection = normalize(pFarWS - rayOrigin); // direction

    //// Passage en LOCAL SPACE du volume
    //float3 rayOriginLS = TransformPoint_WorldToLocal(rayOrigin);
    ////float3 rayDirectionLS = normalize(TransformDir_WorldToLocal(rayDirection));
    //float3 rayDirectionLS = TransformDir_WorldToLocal(rayDirection);
    //rayDirectionLS /= max(length(rayDirectionLS), 1e-8); // normalisation en LS
    
    // Reconstruction du rayon monde à partir de la caméra :
    float3 pNearWS = UnprojectToWorld(uv, 0.0);
    float3 pFarWS = UnprojectToWorld(uv, 1.0);
    //float3 rayOrigin = CameraPosWS; // origine = caméra 
    float3 rayOrigin = pNearWS;
    float3 rayDirection = normalize(pFarWS - rayOrigin); // direction

    // Passage en LOCAL SPACE du volume
    float3 rayOriginLS = TransformPoint_WorldToLocal(rayOrigin);
    //float3 rayDirectionLS = normalize(TransformDir_WorldToLocal(rayDirection));
    float3 rayDirectionLS = TransformDir_WorldToLocal(rayDirection);
    rayDirectionLS /= max(length(rayDirectionLS), 1e-8); // normalisation en LS
    
    // ===================== ICI : BLOCS DEBUG =====================
#if defined(RM_DEBUG) && RM_DEBUG == 1
    // 1) Test AABB union (vert si hit, transparent sinon)
    float3 boxMinLS = UnionMinLS4.xyz;
    float3 boxMaxLS = UnionMaxLS4.xyz;
    float t0, t1;
    bool inside = IntersectRayAABB_Slab(rayOriginLS, rayDirectionLS, boxMinLS, boxMaxLS, t0, t1);
    OutTex[DTid.xy] = inside ? float4(0, 1, 0, 1) : float4(0, 0, 0, 0);
    return;
#endif
    
#if defined(RM_DEBUG) && RM_DEBUG == 2
    // 2) Validation structure octree : renvoie jaune si on touche au moins une feuille/élément AABB
    bool touched = false;

    // Quick stack-based traversal (no cell tests)
    int   stackNode[MAX_STACK];
    float stackTN  [MAX_STACK];
    int sp = 0;

    // Intersect root
    {
        float3 bmin = OctNodeCenter[RootIndex] - OctNodeExtent[RootIndex];
        float3 bmax = OctNodeCenter[RootIndex] + OctNodeExtent[RootIndex];
        float tt0, tt1;
        if (IntersectRayAABB_Slab(rayOriginLS, rayDirectionLS, bmin, bmax, tt0, tt1))
        { stackNode[sp]=RootIndex; stackTN[sp]=tt0; sp++; }
    }

    [loop]
    while (sp > 0 && !touched)
    {
        // pop min tNear
        int bestI = 0; float bestTN = stackTN[0];
        [unroll(64)]
        for (int i=1;i<64;i++){ if (i>=sp) break; if (stackTN[i]<bestTN){bestTN=stackTN[i];bestI=i;} }
        sp--;
        int node = stackNode[bestI];
        stackNode[bestI] = stackNode[sp];
        stackTN  [bestI] = stackTN  [sp];

        uint childCount = OctNodeChildCount[node];
        if (childCount == 0u)
        {
            // leaf: test les éléments (AABB only)
            int  e0 = OctNodeFirstElem[node];
            uint ec = OctNodeElemCount[node];

            float3 pad = max(0.5 * EpsCm, 0.25).xxx;

            [loop]
            for (uint k=0; k<ec; ++k)
            {
                int e = e0 + int(k);
                float3 ebmin = ElemMin[e] - pad;
                float3 ebmax = ElemMax[e] + pad;
                float tt0, tt1;
                if (IntersectRayAABB_Slab(rayOriginLS, rayDirectionLS, ebmin, ebmax, tt0, tt1))
                { touched = true; break; }
            }
        }
        else
        {
            int fc = OctNodeFirstChild[node];
            [unroll(8)]
            for (uint i=0; i<8; ++i)
            {
                if (i >= childCount) break;
                int c = NodeChildIndex[fc + int(i)];
                float3 bmin = OctNodeCenter[c] - OctNodeExtent[c];
                float3 bmax = OctNodeCenter[c] + OctNodeExtent[c];
                float tt0, tt1;
                if (IntersectRayAABB_Slab(rayOriginLS, rayDirectionLS, bmin, bmax, tt0, tt1))
                {
                    if (sp < MAX_STACK) { stackNode[sp]=c; stackTN[sp]=tt0; sp++; }
                }
            }
        }
    }

    OutTex[DTid.xy] = touched ? float4(1,1,0,1) : float4(0,0,0,0);
    return;
#endif
    
#if RM_DEBUG == 3
    // 3) Visualiser l’index cellule (arc-en-ciel). Vérifie la variété des ci touchés.
    int ci; float th;
    bool ok = RaycastFirstCellLS(rayOriginLS, rayDirectionLS, ci, th);
    if (ok && ci >= 0 && ci < int(NumCells)) {
        float3 c = frac(float3(ci, ci*0.37, ci*0.73) * 0.013); 
        OutTex[DTid.xy] = float4(c, 1);
    } else {
        OutTex[DTid.xy] = float4(0,0,0,0);
    }
    return;
#endif
    
#if defined(RM_DEBUG) && RM_DEBUG == 4
    // 4) Feature en niveaux de gris + alpha profondeur normalisée.
    int ci;
    float th;
    bool ok = RaycastFirstCellLS(rayOriginLS, rayDirectionLS, ci, th);

    float v = (ok && ci >= 0 && ci < int(NumCells)) ? FeatureVals[ci] : 0.0;

    // Normalisation sûre
    float denom = max(VMax - VMin, 1e-6);
    float L = saturate((v - VMin) / denom);

    // Alpha = profondeur normalisée (comme le pass final)
    float3 boxMinLS = UnionMinLS4.xyz;
    float3 boxMaxLS = UnionMaxLS4.xyz;
    float maxD = max(length(boxMaxLS - boxMinLS), 1e-3);
    float aNorm = ok ? saturate(th / maxD) : 0.0;

    // Option anti-NaN (si tu suspectes des données sales)
    // if (!isfinite(L)) L = 0.0;

    OutTex[DTid.xy] = float4(L, L, L, aNorm);
    return;
#endif
#if defined(RM_DEBUG) && RM_DEBUG == 5
    // Affiche l’AABB du nœud d’octree le plus proche touché par le rayon.
    // Aucune intersection de cellules, pas de pile : on scanne tous les nœuds.

    float3 uMin = UnionMinLS4.xyz;
    float3 uMax = UnionMaxLS4.xyz;

    // Si le rayon ne touche même pas l’union, on sort (noir).
    float u0, u1;
    if (!IntersectRayAABB_Slab(rayOriginLS, rayDirectionLS, uMin, uMax, u0, u1))
    {
        OutTex[DTid.xy] = 0;
        return;
    }

    float bestT = 1e30;
    int bestN = -1;
    uint maxScan = NumNodes; //limiter: min(NumNodes, 50000u)

    [loop]
    for (uint n = 0u; n < maxScan; ++n)
    {
        float3 bmin = OctNodeCenter[n] - OctNodeExtent[n];
        float3 bmax = OctNodeCenter[n] + OctNodeExtent[n];

        float t0, t1;
        if (!IntersectRayAABB_Slab(rayOriginLS, rayDirectionLS, bmin, bmax, t0, t1))
            continue;
        if (t0 < 0.0)
            t0 = 0.0;
        if (t0 < bestT)
        {
            bestT = t0;
            bestN = int(n);
        }
    }

    if (bestN >= 0)
    {
        // Couleur: cyan pour inner, jaune pour leaf.
        bool isLeaf = (OctNodeChildCount[bestN] == 0u);
        float3 col = isLeaf ? float3(1, 1, 0) : float3(0, 1, 1);

        // Alpha ~ profondeur normalisée dans l’union
        float maxD = max(length(uMax - uMin), 1e-3);
        float aNorm = saturate(bestT / maxD);

        OutTex[DTid.xy] = float4(col, aNorm);
    }
    else
    {
        OutTex[DTid.xy] = 0;
    }
    return;
#endif
#if defined(RM_DEBUG) && RM_DEBUG == 6
{
    float3 roWS = CameraPosWS;
    float3 rdWS = normalize(pFarWS - roWS);

    float3 roLS = TransformPoint_WorldToLocal(roWS);
    float3 rdLS = TransformDir_WorldToLocal(rdWS);
    rdLS /= max(length(rdLS), 1e-8);

    float3 uMin = min(UnionMinLS4.xyz, UnionMaxLS4.xyz);
    float3 uMax = max(UnionMinLS4.xyz, UnionMaxLS4.xyz);

    float t0, t1;
    bool hit = IntersectRayAABB_Slab(roLS, rdLS, uMin, uMax, t0, t1);

    // Alpha = profondeur normalisée dans la bbox
    float maxD = max(length(uMax - uMin), 1e-3);
    float a = hit ? saturate(max(0.0, t0) / maxD) : 0.0;

    OutTex[DTid.xy] = hit ? float4(0,1,0, a) : float4(0,0,0,0);
    return;
}
#endif
#if defined(RM_DEBUG) && RM_DEBUG == 7
{
    float3 pNearWS = UnprojectToWorld(uv, 0.0);
    float3 pFarWS  = UnprojectToWorld(uv, 1.0);

    float3 roWS = CameraPosWS;
    float3 rdWS = normalize(pFarWS - roWS);

    // Affiche la direction (monde) encodée en RGB
    float3 dirRGB = 0.5 * (normalize(rdWS) + 1.0); // [-1..1] -> [0..1]
    OutTex[DTid.xy] = float4(dirRGB, 1.0);
    return;
}
#endif
#if defined(RM_DEBUG) && RM_DEBUG == 8
{
        OutTex[DTid.xy] = float4(uv, 0, 1);
        return;
}
#endif
    // ================== FIN BLOCS DEBUG =========================
    
    

    // Diagonale (LS == WS si scale=1) — sert à normaliser l’alpha “profondeur”.
    float maxDepth = length(UnionMaxLS4.xyz - UnionMinLS4.xyz);
    maxDepth = max(maxDepth, 1e-3);

    // Raycast
    int hitCi;
    float tHit;
    bool hit = RaycastFirstCellLS(rayOriginLS, rayDirectionLS, hitCi, tHit);

    float4 outRGBA = float4(0, 0, 0, 0);

    if (hit)
    {
        // Couleur depuis FeatureVals[hitCi]
        float v = FeatureVals[hitCi];
        float3 rgb = ScalarToColorRGB(v, VMin, VMax);

        // Alpha = distance caméra->hit / diagonale active (identique logique CPU)
        // Comme scale=1: distance monde ~= distance local = tHit (rayDirectionLS normalisé)
        float hitDist = tHit;
        float aNorm = saturate(hitDist / maxDepth);

        outRGBA = float4(rgb, aNorm);
    }

    OutTex[DTid.xy] = outRGBA;
}
